'use strict';

const remRegex = /"[^"]+"|'[^']+'|url\([^)]+\)|var\([^)]+\)|(\d*\.?\d+)rem/g;

function _defu(baseObject, defaults, namespace = ".", merger) {
  if (!_isPlainObject(defaults)) {
    return _defu(baseObject, {}, namespace, merger);
  }
  const object = Object.assign({}, defaults);
  for (const key in baseObject) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = baseObject[key];
    if (value === null || value === void 0) {
      continue;
    }
    if (merger && merger(object, key, value, namespace)) {
      continue;
    }
    if (Array.isArray(value) && Array.isArray(object[key])) {
      object[key] = [...value, ...object[key]];
    } else if (_isPlainObject(value) && _isPlainObject(object[key])) {
      object[key] = _defu(
        value,
        object[key],
        (namespace ? `${namespace}.` : "") + key.toString(),
        merger
      );
    } else {
      object[key] = value;
    }
  }
  return object;
}
function _isPlainObject(value) {
  if (value === null || typeof value !== "object") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);
}
function createDefu(merger) {
  return (...arguments_) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    arguments_.reduce((p, c) => _defu(p, c, "", merger), {})
  );
}

const defaultOptions = {
  rootValue: 16,
  unitPrecision: 5,
  selectorBlackList: [],
  propList: ["font", "font-size", "line-height", "letter-spacing"],
  replace: true,
  mediaQuery: false,
  minRemValue: 0,
  exclude: [/node_modules/i],
  transformUnit: "px",
  disabled: false
};

const postcssPlugin = "postcss-rem-to-responsive-pixel";
const defu = createDefu((obj, key, value) => {
  if (Array.isArray(obj[key]) && Array.isArray(value)) {
    obj[key] = value;
    return true;
  }
});
function getConfig(options) {
  return defu(
    options,
    defaultOptions
  );
}
function createRemReplace(rootValue, unitPrecision, minRemValue, transformUnit = "px") {
  return function(m, $1) {
    if (!$1)
      return m;
    const rems = Number.parseFloat($1);
    if (rems < minRemValue)
      return m;
    const fixedVal = toFixed(rems * rootValue, unitPrecision);
    return fixedVal === 0 ? "0" : fixedVal + transformUnit;
  };
}
function toFixed(number, precision) {
  const multiplier = Math.pow(10, precision + 1);
  const wholeNumber = Math.floor(number * multiplier);
  return Math.round(wholeNumber / 10) * 10 / multiplier;
}
function declarationExists(decls, prop, value) {
  return decls.some((decl) => {
    const d = decl;
    return d.prop === prop && d.value === value;
  });
}
function blacklistedSelector(blacklist, selector) {
  if (typeof selector !== "string")
    return;
  return blacklist.some((regex) => {
    if (typeof regex === "string") {
      return selector.includes(regex);
    }
    return selector.match(regex);
  });
}
function createPropListMatcher(propList) {
  const hasWild = propList.includes("*");
  return function(prop) {
    if (hasWild)
      return true;
    return propList.some((regex) => {
      if (typeof regex === "string") {
        return prop.includes(regex);
      }
      return prop.match(regex);
    });
  };
}
function createExcludeMatcher(exclude) {
  return function(filepath) {
    if (filepath === void 0) {
      return false;
    }
    return Array.isArray(exclude) ? exclude.some((regex) => {
      if (typeof regex === "string") {
        return filepath.includes(regex);
      }
      return filepath.match(regex);
    }) : exclude(filepath);
  };
}

const plugin = (options = {}) => {
  const {
    exclude,
    mediaQuery,
    minRemValue,
    propList,
    replace,
    rootValue,
    selectorBlackList,
    transformUnit,
    unitPrecision,
    disabled
  } = getConfig(options);
  if (disabled) {
    return {
      postcssPlugin
    };
  }
  const satisfyPropList = createPropListMatcher(propList);
  const excludeFn = createExcludeMatcher(exclude);
  return {
    postcssPlugin,
    Once(css) {
      const source = css.source;
      const input = source.input;
      const filePath = input.file;
      const isExcludeFile = excludeFn(filePath);
      if (isExcludeFile)
        return;
      const _rootValue = typeof rootValue === "function" ? rootValue(input) : rootValue;
      const pxReplace = createRemReplace(
        _rootValue,
        unitPrecision,
        minRemValue,
        transformUnit
      );
      css.walkDecls((decl) => {
        const rule = decl.parent;
        if (!decl.value.includes("rem") || !satisfyPropList(decl.prop) || blacklistedSelector(selectorBlackList, rule.selector)) {
          return;
        }
        const value = decl.value.replace(remRegex, pxReplace);
        if (declarationExists(rule, decl.prop, value))
          return;
        if (replace) {
          decl.value = value;
        } else {
          decl.cloneAfter({ value });
        }
      });
      css.walkAtRules((atRule) => {
        if (mediaQuery && atRule.name === "media") {
          if (!atRule.params.includes("rem"))
            return;
          atRule.params = atRule.params.replace(remRegex, pxReplace);
        }
      });
    }
  };
};
plugin.postcss = true;

module.exports = plugin;
