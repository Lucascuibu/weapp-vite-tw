// src/context.ts
import process2 from "node:process";
import path5 from "pathe";
import { build, loadConfigFromFile } from "vite";
import { watch } from "chokidar";
import { addExtension as addExtension3, defu as defu3, removeExtension as removeExtension3 } from "@weapp-core/shared";
import tsconfigPaths from "vite-tsconfig-paths";
import fs4 from "fs-extra";

// src/utils/projectConfig.ts
import path from "pathe";
import fs from "fs-extra";
function getProjectConfig(root, options) {
  const baseJsonPath = path.resolve(root, "project.config.json");
  const privateJsonPath = path.resolve(root, "project.private.config.json");
  let baseJson = {};
  let privateJson = {};
  if (fs.existsSync(baseJsonPath)) {
    try {
      baseJson = fs.readJsonSync(baseJsonPath) || {};
    } catch {
      throw new Error(`\u89E3\u6790 json \u683C\u5F0F\u5931\u8D25, project.config.json \u4E3A\u975E\u6CD5\u7684 json \u683C\u5F0F`);
    }
  } else {
    throw new Error(`\u5728 ${root} \u76EE\u5F55\u4E0B\u627E\u4E0D\u5230 project.config.json`);
  }
  if (!options?.ignorePrivate) {
    if (fs.existsSync(privateJsonPath)) {
      try {
        privateJson = fs.readJsonSync(privateJsonPath) || {};
      } catch {
        throw new Error(`\u89E3\u6790 json \u683C\u5F0F\u5931\u8D25, project.private.config.json \u4E3A\u975E\u6CD5\u7684 json \u683C\u5F0F`);
      }
    }
  }
  return Object.assign({}, privateJson, baseJson);
}

// src/defaults.ts
var defaultExcluded = ["**/node_modules/**", "**/miniprogram_npm/**"];
function getWeappWatchOptions() {
  return {
    paths: ["**/*.{wxml,json,wxs}", "**/*.{png,jpg,jpeg,gif,svg,webp}", ".env", ".env.*"],
    ignored: [
      ...defaultExcluded
    ]
  };
}

// src/plugins/index.ts
import path4 from "pathe";
import fs3 from "fs-extra";
import MagicString from "magic-string";
import { addExtension as addExtension2, removeExtension as removeExtension2 } from "@weapp-core/shared";
import { isCSSRequest, preprocessCSS } from "vite";
import fg from "fast-glob";

// src/utils/scan.ts
import path2 from "pathe";
import fs2 from "fs-extra";
import { addExtension, defu, isObject, removeExtension } from "@weapp-core/shared";
function parseJsonUseComponents(json) {
  const deps = [];
  if (isObject(json.usingComponents)) {
    deps.push(...Object.values(json.usingComponents).map((x) => {
      return {
        path: x,
        type: "component"
      };
    }));
  }
  return deps;
}
function searchAppEntry(options) {
  const { formatPath, root } = defu(options, {
    formatPath: (x) => x
  });
  const extensions = ["js", "ts"];
  const appJsonPath = path2.resolve(root, "app.json");
  if (fs2.existsSync(appJsonPath)) {
    for (const ext of extensions) {
      const entryPath = path2.resolve(root, addExtension("app", `.${ext}`));
      if (fs2.existsSync(entryPath)) {
        const appJson = fs2.readJSONSync(appJsonPath, { throws: false });
        const deps = [];
        if (appJson) {
          if (Array.isArray(appJson.pages)) {
            deps.push(...appJson.pages.map((x) => {
              return {
                path: x,
                type: "page"
              };
            }));
          }
          if (isObject(appJson.usingComponents)) {
            deps.push(...parseJsonUseComponents(appJson));
          }
          if (Array.isArray(appJson.subPackages)) {
            deps.push(...appJson.subPackages.map((x) => {
              return {
                type: "subPackage",
                ...x
              };
            }));
          }
        }
        return {
          jsonPath: formatPath(appJsonPath),
          json: appJson,
          path: formatPath(entryPath),
          deps,
          type: "app"
        };
      }
    }
  }
}
function searchPageEntry(wxmlPath) {
  if (fs2.existsSync(wxmlPath)) {
    const extensions = ["js", "ts"];
    const base = removeExtension(wxmlPath);
    for (const ext of extensions) {
      const entryPath = addExtension(base, `.${ext}`);
      if (fs2.existsSync(entryPath)) {
        return entryPath;
      }
    }
  }
}
function getWxmlEntry(wxmlPath, formatPath) {
  const pageEntry = searchPageEntry(wxmlPath);
  if (pageEntry) {
    const jsonPath = addExtension(removeExtension(wxmlPath), ".json");
    const finalPath = formatPath(pageEntry);
    if (fs2.existsSync(jsonPath)) {
      const json = fs2.readJsonSync(jsonPath, { throws: false });
      if (json && json.component) {
        return {
          deps: parseJsonUseComponents(json),
          path: finalPath,
          type: "component",
          json,
          jsonPath: formatPath(jsonPath)
        };
      } else {
        return {
          deps: parseJsonUseComponents(json),
          path: finalPath,
          type: "page",
          json,
          jsonPath: formatPath(jsonPath)
        };
      }
    }
    return {
      deps: [],
      path: finalPath,
      type: "page"
      // json: undefined,
      // jsonPath: undefined,
    };
  }
}

// src/utils/index.ts
var supportedCssLangs = ["wxss", "scss", "less", "sass", "styl"];
var supportedCssExtensions = supportedCssLangs.map((x) => `.${x}`);

// src/entry.ts
import process from "node:process";
import mm from "micromatch";
import { defu as defu2 } from "@weapp-core/shared";
import path3 from "pathe";
import klaw from "klaw";
function createFilter(include, exclude, options) {
  const opts = defu2(options, {
    ignore: exclude
  });
  return function(id) {
    if (typeof id !== "string") {
      return false;
    }
    if (/\0/.test(id)) {
      return false;
    }
    return mm.isMatch(id, include, opts);
  };
}
async function getEntries(options) {
  const { root = process.cwd(), outDir = "dist", relative, srcRoot = "", subPackage } = options;
  function formatPath(to) {
    if (relative) {
      return path3.relative(root, to);
    }
    return path3.normalize(to);
  }
  if (subPackage) {
    const subPackageRoot = subPackage.root ?? "";
    const filter = createFilter(
      [path3.join(root, srcRoot, subPackageRoot, "**/*")],
      [
        ...defaultExcluded
      ],
      { cwd: root }
    );
    const pageEntries = [];
    const componentEntries = [];
    const subPackageEntries = [];
    if (subPackage.entry) {
      subPackageEntries.push({
        deps: [],
        path: path3.join(root, subPackageRoot, subPackage.entry),
        type: "subPackageEntry"
      });
    }
    for await (const file of klaw(
      path3.join(root, subPackageRoot),
      {
        filter
      }
    )) {
      if (file.stats.isFile()) {
        if (/\.wxml$/.test(file.path)) {
          const entry = getWxmlEntry(file.path, formatPath);
          if (entry) {
            if (entry.type === "component") {
              componentEntries.push(entry);
            } else if (entry.type === "page") {
              pageEntries.push(entry);
            }
          }
        }
      }
    }
    return {
      pages: pageEntries,
      components: componentEntries,
      subPackageEntries
    };
  } else {
    const appEntry = searchAppEntry({
      root: path3.join(root, srcRoot),
      formatPath
    });
    if (appEntry) {
      const subPackageDeps = appEntry.deps.filter((x) => x.type === "subPackage");
      const filter = createFilter(
        [path3.join(root, srcRoot, "**/*")],
        [
          ...defaultExcluded,
          path3.join(root, `${outDir}/**`),
          ...subPackageDeps.map((x) => {
            return path3.join(root, `${x.root}/**`);
          })
        ],
        { cwd: root }
      );
      const pageEntries = [];
      const componentEntries = [];
      for await (const file of klaw(
        path3.join(root, srcRoot),
        {
          filter
        }
      )) {
        if (file.stats.isFile()) {
          if (/\.wxml$/.test(file.path)) {
            const entry = getWxmlEntry(file.path, formatPath);
            if (entry) {
              if (entry.type === "component") {
                componentEntries.push(entry);
              } else if (entry.type === "page") {
                pageEntries.push(entry);
              }
            }
          }
        }
      }
      return {
        app: appEntry,
        pages: pageEntries,
        components: componentEntries,
        subPackages: subPackageDeps
        // walkPathsSet,
      };
    }
  }
}

// src/debugger.ts
import createDebug from "debug";
function createDebugger(namespace) {
  const debug2 = createDebug(namespace);
  if (debug2.enabled) {
    return debug2;
  }
}

// src/plugins/parse.ts
function parseRequest(id) {
  const [filename, rawQuery] = id.split(`?`, 2);
  const query = Object.fromEntries(new URLSearchParams(rawQuery));
  if (Reflect.has(query, "wxss")) {
    query.wxss = true;
  }
  return {
    filename,
    query
  };
}

// src/plugins/index.ts
var debug = createDebugger("weapp-vite:plugin");
function normalizeCssPath(id) {
  return addExtension2(removeExtension2(id), ".wxss");
}
function getRealPath(res) {
  if (res.query.wxss) {
    return addExtension2(removeExtension2(res.filename), ".wxss");
  }
  return res.filename;
}
function vitePluginWeapp(ctx) {
  const stylesIds = /* @__PURE__ */ new Set();
  let configResolved;
  let entriesSet = /* @__PURE__ */ new Set();
  function relative(p) {
    return path4.relative(configResolved.root, p);
  }
  function getInputOption(entries) {
    return entries.reduce((acc, cur) => {
      acc[relative(cur)] = cur;
      return acc;
    }, {});
  }
  let appEntry;
  return [
    {
      name: "weapp-vite:pre",
      enforce: "pre",
      api: {},
      // config->configResolved->|watching|options->buildStart
      config(config, env) {
        debug?.(config, env);
      },
      configResolved(config) {
        debug?.(config);
        configResolved = config;
      },
      async options(options) {
        const { root, build: build2, weapp } = configResolved;
        const entries = await getEntries({
          root,
          outDir: build2.outDir,
          srcRoot: weapp?.srcRoot,
          subPackage: weapp?.subPackage
        });
        if (entries) {
          const paths = [];
          if (entries.app) {
            paths.push(entries.app.path);
            appEntry = entries.app;
          }
          paths.push(...[...entries.pages, ...entries.components].map((x) => {
            return x.path;
          }));
          if (entries.subPackageEntries) {
            paths.push(...entries.subPackageEntries.map((x) => {
              return x.path;
            }));
          }
          const input = getInputOption(paths);
          entriesSet = new Set(paths);
          options.input = input;
          if (weapp?.type === "app" && Array.isArray(entries.subPackages) && entries.subPackages.length) {
            for (const subPackage of entries.subPackages) {
              if (subPackage.root && !ctx.subPackageContextMap.has(subPackage.root)) {
                ctx.forkSubPackage(subPackage).build();
              }
            }
          }
        } else {
          throw new Error(`\u5728 ${path4.join(root, ctx.srcRoot ?? "")} \u76EE\u5F55\u4E0B\u6CA1\u6709\u627E\u5230 \`app.json\`, \u8BF7\u786E\u4FDD\u4F60\u521D\u59CB\u5316\u4E86\u5C0F\u7A0B\u5E8F\u9879\u76EE\uFF0C\u6216\u8005\u5728 \`vite.config.ts\` \u4E2D\u8BBE\u7F6E\u7684\u6B63\u786E\u7684 \`weapp.srcRoot\` \u914D\u7F6E\u8DEF\u5F84  `);
        }
      },
      async buildStart() {
        const { root, build: build2, weapp } = configResolved;
        let cwd = root;
        const ignore = [
          ...defaultExcluded
        ];
        const isSubPackage = weapp?.type === "subPackage";
        if (isSubPackage) {
          cwd = path4.join(root, ctx.subPackage.root);
        } else {
          const ignoreSubPackage = appEntry ? appEntry.deps.filter(
            (x) => x.type === "subPackage"
          ).map((x) => {
            return `${x.root}/**`;
          }) : [];
          ignore.push(
            ...[
              `${build2.outDir}/**`,
              ...ignoreSubPackage,
              "project.config.json",
              "project.private.config.json",
              "package.json",
              "tsconfig.json",
              "tsconfig.node.json"
            ]
          );
        }
        const files = await fg(
          // 假如去 join root 就是返回 absolute
          [path4.join(ctx.srcRoot ?? "", "**/*.{wxml,json,wxs,png,jpg,jpeg,gif,svg,webp}")],
          {
            cwd,
            ignore,
            absolute: false
          }
        );
        const relFiles = files.map((x) => {
          return isSubPackage ? path4.join(weapp?.subPackage?.root ?? "", x) : x;
        });
        for (const file of relFiles) {
          const filepath = path4.resolve(ctx.cwd, file);
          this.addWatchFile(filepath);
          const isMedia = !/\.(?:wxml|json|wxs)$/.test(file);
          this.emitFile({
            type: "asset",
            fileName: ctx.relativeSrcRoot(file),
            source: isMedia ? await fs3.readFile(filepath) : await fs3.readFile(filepath, "utf8")
          });
        }
      },
      resolveId(source) {
        if (/\.wxss$/.test(source)) {
          return source.replace(/\.wxss$/, ".css?wxss");
        }
      },
      load(id) {
        if (entriesSet.has(id)) {
          const base = removeExtension2(id);
          const ms = new MagicString(fs3.readFileSync(id, "utf8"));
          for (const ext of supportedCssExtensions) {
            const mayBeCssPath = addExtension2(base, ext);
            if (fs3.existsSync(mayBeCssPath)) {
              this.addWatchFile(mayBeCssPath);
              ms.prepend(`import '${mayBeCssPath}'
`);
            }
          }
          this.addWatchFile(id);
          return {
            code: ms.toString()
          };
        } else if (isCSSRequest(id)) {
          stylesIds.add(id);
          return {
            code: ""
          };
        }
      },
      async buildEnd() {
        const styles = {};
        for (const stylesId of stylesIds) {
          const parsed = parseRequest(stylesId);
          const realPath = getRealPath(parsed);
          if (await fs3.exists(realPath)) {
            const css = await fs3.readFile(realPath, "utf8");
            const res = await preprocessCSS(css, stylesId, configResolved);
            const fileName = relative(normalizeCssPath(stylesId));
            if (styles[fileName]) {
              styles[fileName] += res.code;
            } else {
              styles[fileName] = res.code;
            }
          } else {
            stylesIds.delete(stylesId);
          }
        }
        for (const style of Object.entries(styles)) {
          this.emitFile({
            type: "asset",
            fileName: ctx.relativeSrcRoot(style[0]),
            source: style[1]
          });
        }
      }
      // generateBundle(_options, _bundle) {
      //   const files = this.getWatchFiles()
      //   console.log(files)
      // },
    },
    {
      name: "weapp-vite"
    },
    {
      name: "weapp-vite:post",
      enforce: "post"
    }
  ];
}

// src/context.ts
var CompilerContext = class _CompilerContext {
  inlineConfig;
  cwd;
  isDev;
  projectConfig;
  mode;
  packageJson;
  subPackage;
  watcherMap;
  subPackageContextMap;
  type;
  parent;
  constructor(options) {
    const { cwd, isDev, inlineConfig, projectConfig, mode, packageJson, subPackage, type } = defu3(options, {
      cwd: process2.cwd(),
      isDev: false,
      projectConfig: {},
      type: "app",
      inlineConfig: {},
      mode: "",
      packageJson: {}
    });
    this.cwd = cwd;
    this.inlineConfig = inlineConfig;
    this.isDev = isDev;
    this.projectConfig = projectConfig;
    this.mode = mode;
    this.packageJson = packageJson;
    this.subPackage = subPackage;
    this.watcherMap = /* @__PURE__ */ new Map();
    this.subPackageContextMap = /* @__PURE__ */ new Map();
    this.type = type;
  }
  get srcRoot() {
    return this.inlineConfig?.weapp?.srcRoot;
  }
  relativeSrcRoot(p) {
    if (this.srcRoot) {
      return path5.relative(this.srcRoot, p);
    }
    return p;
  }
  get mpDistRoot() {
    return this.projectConfig.miniprogramRoot || this.projectConfig.srcMiniprogramRoot || "";
  }
  // get weappConfig() {
  //   return this.inlineConfig.weapp
  // }
  // get inlineSubPackageConfig() {
  //   return this.weappConfig?.subPackage
  // }
  forkSubPackage(subPackage) {
    const ctx = new _CompilerContext({
      cwd: this.cwd,
      isDev: this.isDev,
      projectConfig: this.projectConfig,
      inlineConfig: this.inlineConfig,
      type: "subPackage",
      mode: this.mode,
      subPackage
    });
    this.subPackageContextMap.set(subPackage.root, ctx);
    ctx.parent = this;
    return ctx;
  }
  async internalDev(inlineConfig) {
    const rollupWatcher = await build(
      inlineConfig
    );
    const key = "rollup";
    const watcher = this.watcherMap.get(key);
    watcher?.close();
    this.watcherMap.set(key, rollupWatcher);
    return rollupWatcher;
  }
  async runDev() {
    if (process2.env.NODE_ENV === void 0) {
      process2.env.NODE_ENV = "development";
    }
    const inlineConfig = defu3(
      this.inlineConfig,
      {
        root: this.cwd,
        mode: "development",
        plugins: [vitePluginWeapp(this)],
        build: {
          watch: {},
          minify: false,
          emptyOutDir: false
        },
        weapp: {
          type: "app"
        }
      }
    );
    const getWatcher = (paths, opts, inlineConfig2) => {
      const watcher = watch(paths, opts);
      let isReady = false;
      watcher.on("all", async (eventName) => {
        if (isReady && (eventName === "add" || eventName === "change" || eventName === "unlink")) {
          await this.internalDev(inlineConfig2);
        }
      }).on("ready", async () => {
        await this.internalDev(inlineConfig2);
        isReady = true;
      });
      return watcher;
    };
    if (this.type === "subPackage" && this.subPackage) {
      const subPackageInlineConfig = Object.assign({}, inlineConfig, {
        weapp: {
          srcRoot: this.parent?.srcRoot,
          type: this.type,
          subPackage: this.subPackage
        }
      });
      const { paths, ...opts } = defu3(
        subPackageInlineConfig.weapp?.watch,
        {
          cwd: path5.join(this.cwd, subPackageInlineConfig.weapp.srcRoot ?? "", this.subPackage.root)
        },
        getWeappWatchOptions()
      );
      const watcher = getWatcher(paths, opts, subPackageInlineConfig);
      this.watcherMap.set(this.subPackage.root, watcher);
      return watcher;
    } else if (this.type === "app") {
      const { paths, ...opts } = defu3(
        inlineConfig.weapp?.watch,
        {
          ignored: [
            path5.join(this.mpDistRoot, "**")
          ],
          cwd: this.cwd
        },
        getWeappWatchOptions()
      );
      const watcher = getWatcher(paths, opts, inlineConfig);
      this.watcherMap.set("/", watcher);
      return watcher;
    }
  }
  async runProd() {
    const inlineConfig = defu3(
      this.inlineConfig,
      {
        root: this.cwd,
        plugins: [vitePluginWeapp(this)],
        mode: "production",
        weapp: {
          type: "app"
        }
      }
    );
    const output = await build(
      inlineConfig
    );
    return output;
  }
  build() {
    if (this.isDev) {
      return this.runDev();
    } else {
      return this.runProd();
    }
  }
  async loadDefaultConfig() {
    const projectConfig = getProjectConfig(this.cwd);
    this.projectConfig = projectConfig;
    const packageJsonPath = path5.resolve(this.cwd, "package.json");
    const external = [];
    if (await fs4.exists(packageJsonPath)) {
      const localPackageJson = await fs4.readJson(packageJsonPath, {
        throws: false
      }) || {};
      this.packageJson = localPackageJson;
      if (localPackageJson.dependencies) {
        external.push(...Object.keys(localPackageJson.dependencies));
      }
    }
    const loaded = await loadConfigFromFile({
      command: this.isDev ? "serve" : "build",
      mode: this.mode
    }, void 0, this.cwd);
    this.inlineConfig = defu3({
      mode: this.mode,
      build: {
        rollupOptions: {
          output: {
            format: "cjs",
            strict: false,
            entryFileNames: (chunkInfo) => {
              const name = this.relativeSrcRoot(chunkInfo.name);
              if (name.endsWith(".ts")) {
                const baseFileName = removeExtension3(name);
                if (baseFileName.endsWith(".wxs")) {
                  return path5.normalize(baseFileName);
                }
                return path5.normalize(addExtension3(baseFileName, ".js"));
              }
              return path5.normalize(name);
            }
          },
          external
        },
        assetsDir: ".",
        commonjsOptions: {
          transformMixedEsModules: true,
          include: void 0
        }
      },
      plugins: [
        tsconfigPaths()
      ],
      configFile: false
    }, loaded?.config, this.inlineConfig);
  }
};

export {
  CompilerContext
};
