"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/cli.ts
var import_node_process3 = __toESM(require("process"), 1);
var import_cac = require("cac");
var import_init = require("@weapp-core/init");
var import_weapp_ide_cli = require("weapp-ide-cli");

// src/logger.ts
var import_logger = __toESM(require("@weapp-core/logger"), 1);
var logger_default = import_logger.default;

// src/context.ts
var import_node_process2 = __toESM(require("process"), 1);
var import_pathe5 = __toESM(require("pathe"), 1);
var import_vite2 = require("vite");
var import_chokidar = require("chokidar");
var import_shared4 = require("@weapp-core/shared");
var import_vite_tsconfig_paths = __toESM(require("vite-tsconfig-paths"), 1);
var import_fs_extra4 = __toESM(require("fs-extra"), 1);

// src/utils/projectConfig.ts
var import_pathe = __toESM(require("pathe"), 1);
var import_fs_extra = __toESM(require("fs-extra"), 1);
function getProjectConfig(root, options) {
  const baseJsonPath = import_pathe.default.resolve(root, "project.config.json");
  const privateJsonPath = import_pathe.default.resolve(root, "project.private.config.json");
  let baseJson = {};
  let privateJson = {};
  if (import_fs_extra.default.existsSync(baseJsonPath)) {
    try {
      baseJson = import_fs_extra.default.readJsonSync(baseJsonPath) || {};
    } catch {
      throw new Error(`\u89E3\u6790 json \u683C\u5F0F\u5931\u8D25, project.config.json \u4E3A\u975E\u6CD5\u7684 json \u683C\u5F0F`);
    }
  } else {
    throw new Error(`\u5728 ${root} \u76EE\u5F55\u4E0B\u627E\u4E0D\u5230 project.config.json`);
  }
  if (!options?.ignorePrivate) {
    if (import_fs_extra.default.existsSync(privateJsonPath)) {
      try {
        privateJson = import_fs_extra.default.readJsonSync(privateJsonPath) || {};
      } catch {
        throw new Error(`\u89E3\u6790 json \u683C\u5F0F\u5931\u8D25, project.private.config.json \u4E3A\u975E\u6CD5\u7684 json \u683C\u5F0F`);
      }
    }
  }
  return Object.assign({}, privateJson, baseJson);
}

// src/defaults.ts
var defaultExcluded = ["**/node_modules/**", "**/miniprogram_npm/**"];
function getWeappWatchOptions() {
  return {
    paths: ["**/*.{wxml,json,wxs}", "**/*.{png,jpg,jpeg,gif,svg,webp}", ".env", ".env.*"],
    ignored: [
      ...defaultExcluded
    ]
  };
}

// src/plugins/index.ts
var import_pathe4 = __toESM(require("pathe"), 1);
var import_fs_extra3 = __toESM(require("fs-extra"), 1);
var import_magic_string = __toESM(require("magic-string"), 1);
var import_shared3 = require("@weapp-core/shared");
var import_vite = require("vite");
var import_fast_glob = __toESM(require("fast-glob"), 1);

// src/utils/scan.ts
var import_pathe2 = __toESM(require("pathe"), 1);
var import_fs_extra2 = __toESM(require("fs-extra"), 1);
var import_shared = require("@weapp-core/shared");
function parseJsonUseComponents(json) {
  const deps = [];
  if ((0, import_shared.isObject)(json.usingComponents)) {
    deps.push(...Object.values(json.usingComponents).map((x) => {
      return {
        path: x,
        type: "component"
      };
    }));
  }
  return deps;
}
function searchAppEntry(options) {
  const { formatPath, root } = (0, import_shared.defu)(options, {
    formatPath: (x) => x
  });
  const extensions = ["js", "ts"];
  const appJsonPath = import_pathe2.default.resolve(root, "app.json");
  if (import_fs_extra2.default.existsSync(appJsonPath)) {
    for (const ext of extensions) {
      const entryPath = import_pathe2.default.resolve(root, (0, import_shared.addExtension)("app", `.${ext}`));
      if (import_fs_extra2.default.existsSync(entryPath)) {
        const appJson = import_fs_extra2.default.readJSONSync(appJsonPath, { throws: false });
        const deps = [];
        if (appJson) {
          if (Array.isArray(appJson.pages)) {
            deps.push(...appJson.pages.map((x) => {
              return {
                path: x,
                type: "page"
              };
            }));
          }
          if ((0, import_shared.isObject)(appJson.usingComponents)) {
            deps.push(...parseJsonUseComponents(appJson));
          }
          if (Array.isArray(appJson.subPackages)) {
            deps.push(...appJson.subPackages.map((x) => {
              return {
                type: "subPackage",
                ...x
              };
            }));
          }
        }
        return {
          jsonPath: formatPath(appJsonPath),
          json: appJson,
          path: formatPath(entryPath),
          deps,
          type: "app"
        };
      }
    }
  }
}
function searchPageEntry(wxmlPath) {
  if (import_fs_extra2.default.existsSync(wxmlPath)) {
    const extensions = ["js", "ts"];
    const base = (0, import_shared.removeExtension)(wxmlPath);
    for (const ext of extensions) {
      const entryPath = (0, import_shared.addExtension)(base, `.${ext}`);
      if (import_fs_extra2.default.existsSync(entryPath)) {
        return entryPath;
      }
    }
  }
}
function getWxmlEntry(wxmlPath, formatPath) {
  const pageEntry = searchPageEntry(wxmlPath);
  if (pageEntry) {
    const jsonPath = (0, import_shared.addExtension)((0, import_shared.removeExtension)(wxmlPath), ".json");
    const finalPath = formatPath(pageEntry);
    if (import_fs_extra2.default.existsSync(jsonPath)) {
      const json = import_fs_extra2.default.readJsonSync(jsonPath, { throws: false });
      if (json && json.component) {
        return {
          deps: parseJsonUseComponents(json),
          path: finalPath,
          type: "component",
          json,
          jsonPath: formatPath(jsonPath)
        };
      } else {
        return {
          deps: parseJsonUseComponents(json),
          path: finalPath,
          type: "page",
          json,
          jsonPath: formatPath(jsonPath)
        };
      }
    }
    return {
      deps: [],
      path: finalPath,
      type: "page"
      // json: undefined,
      // jsonPath: undefined,
    };
  }
}

// src/utils/index.ts
var supportedCssLangs = ["wxss", "scss", "less", "sass", "styl"];
var supportedCssExtensions = supportedCssLangs.map((x) => `.${x}`);

// src/entry.ts
var import_node_process = __toESM(require("process"), 1);
var import_micromatch = __toESM(require("micromatch"), 1);
var import_shared2 = require("@weapp-core/shared");
var import_pathe3 = __toESM(require("pathe"), 1);
var import_klaw = __toESM(require("klaw"), 1);
function createFilter(include, exclude, options) {
  const opts = (0, import_shared2.defu)(options, {
    ignore: exclude
  });
  return function(id) {
    if (typeof id !== "string") {
      return false;
    }
    if (/\0/.test(id)) {
      return false;
    }
    return import_micromatch.default.isMatch(id, include, opts);
  };
}
async function getEntries(options) {
  const { root = import_node_process.default.cwd(), outDir = "dist", relative, srcRoot = "", subPackage } = options;
  function formatPath(to) {
    if (relative) {
      return import_pathe3.default.relative(root, to);
    }
    return import_pathe3.default.normalize(to);
  }
  if (subPackage) {
    const subPackageRoot = subPackage.root ?? "";
    const filter = createFilter(
      [import_pathe3.default.join(root, srcRoot, subPackageRoot, "**/*")],
      [
        ...defaultExcluded
      ],
      { cwd: root }
    );
    const pageEntries = [];
    const componentEntries = [];
    const subPackageEntries = [];
    if (subPackage.entry) {
      subPackageEntries.push({
        deps: [],
        path: import_pathe3.default.join(root, subPackageRoot, subPackage.entry),
        type: "subPackageEntry"
      });
    }
    for await (const file of (0, import_klaw.default)(
      import_pathe3.default.join(root, subPackageRoot),
      {
        filter
      }
    )) {
      if (file.stats.isFile()) {
        if (/\.wxml$/.test(file.path)) {
          const entry = getWxmlEntry(file.path, formatPath);
          if (entry) {
            if (entry.type === "component") {
              componentEntries.push(entry);
            } else if (entry.type === "page") {
              pageEntries.push(entry);
            }
          }
        }
      }
    }
    return {
      pages: pageEntries,
      components: componentEntries,
      subPackageEntries
    };
  } else {
    const appEntry = searchAppEntry({
      root: import_pathe3.default.join(root, srcRoot),
      formatPath
    });
    if (appEntry) {
      const subPackageDeps = appEntry.deps.filter((x) => x.type === "subPackage");
      const filter = createFilter(
        [import_pathe3.default.join(root, srcRoot, "**/*")],
        [
          ...defaultExcluded,
          import_pathe3.default.join(root, `${outDir}/**`),
          ...subPackageDeps.map((x) => {
            return import_pathe3.default.join(root, `${x.root}/**`);
          })
        ],
        { cwd: root }
      );
      const pageEntries = [];
      const componentEntries = [];
      for await (const file of (0, import_klaw.default)(
        import_pathe3.default.join(root, srcRoot),
        {
          filter
        }
      )) {
        if (file.stats.isFile()) {
          if (/\.wxml$/.test(file.path)) {
            const entry = getWxmlEntry(file.path, formatPath);
            if (entry) {
              if (entry.type === "component") {
                componentEntries.push(entry);
              } else if (entry.type === "page") {
                pageEntries.push(entry);
              }
            }
          }
        }
      }
      return {
        app: appEntry,
        pages: pageEntries,
        components: componentEntries,
        subPackages: subPackageDeps
        // walkPathsSet,
      };
    }
  }
}

// src/debugger.ts
var import_debug = __toESM(require("debug"), 1);
function createDebugger(namespace) {
  const debug2 = (0, import_debug.default)(namespace);
  if (debug2.enabled) {
    return debug2;
  }
}

// src/plugins/parse.ts
function parseRequest(id) {
  const [filename, rawQuery] = id.split(`?`, 2);
  const query = Object.fromEntries(new URLSearchParams(rawQuery));
  if (Reflect.has(query, "wxss")) {
    query.wxss = true;
  }
  return {
    filename,
    query
  };
}

// src/plugins/index.ts
var debug = createDebugger("weapp-vite:plugin");
function normalizeCssPath(id) {
  return (0, import_shared3.addExtension)((0, import_shared3.removeExtension)(id), ".wxss");
}
function getRealPath(res) {
  if (res.query.wxss) {
    return (0, import_shared3.addExtension)((0, import_shared3.removeExtension)(res.filename), ".wxss");
  }
  return res.filename;
}
function vitePluginWeapp(ctx) {
  const stylesIds = /* @__PURE__ */ new Set();
  let configResolved;
  let entriesSet = /* @__PURE__ */ new Set();
  function relative(p) {
    return import_pathe4.default.relative(configResolved.root, p);
  }
  function getInputOption(entries) {
    return entries.reduce((acc, cur) => {
      acc[relative(cur)] = cur;
      return acc;
    }, {});
  }
  let appEntry;
  return [
    {
      name: "weapp-vite:pre",
      enforce: "pre",
      api: {},
      // config->configResolved->|watching|options->buildStart
      config(config, env) {
        debug?.(config, env);
      },
      configResolved(config) {
        debug?.(config);
        configResolved = config;
      },
      async options(options) {
        const { root, build: build2, weapp } = configResolved;
        const entries = await getEntries({
          root,
          outDir: build2.outDir,
          srcRoot: weapp?.srcRoot,
          subPackage: weapp?.subPackage
        });
        if (entries) {
          const paths = [];
          if (entries.app) {
            paths.push(entries.app.path);
            appEntry = entries.app;
          }
          paths.push(...[...entries.pages, ...entries.components].map((x) => {
            return x.path;
          }));
          if (entries.subPackageEntries) {
            paths.push(...entries.subPackageEntries.map((x) => {
              return x.path;
            }));
          }
          const input = getInputOption(paths);
          entriesSet = new Set(paths);
          options.input = input;
          if (weapp?.type === "app" && Array.isArray(entries.subPackages) && entries.subPackages.length) {
            for (const subPackage of entries.subPackages) {
              if (subPackage.root && !ctx.subPackageContextMap.has(subPackage.root)) {
                ctx.forkSubPackage(subPackage).build();
              }
            }
          }
        } else {
          throw new Error(`\u5728 ${import_pathe4.default.join(root, ctx.srcRoot ?? "")} \u76EE\u5F55\u4E0B\u6CA1\u6709\u627E\u5230 \`app.json\`, \u8BF7\u786E\u4FDD\u4F60\u521D\u59CB\u5316\u4E86\u5C0F\u7A0B\u5E8F\u9879\u76EE\uFF0C\u6216\u8005\u5728 \`vite.config.ts\` \u4E2D\u8BBE\u7F6E\u7684\u6B63\u786E\u7684 \`weapp.srcRoot\` \u914D\u7F6E\u8DEF\u5F84  `);
        }
      },
      async buildStart() {
        const { root, build: build2, weapp } = configResolved;
        let cwd = root;
        const ignore = [
          ...defaultExcluded
        ];
        const isSubPackage = weapp?.type === "subPackage";
        if (isSubPackage) {
          cwd = import_pathe4.default.join(root, ctx.subPackage.root);
        } else {
          const ignoreSubPackage = appEntry ? appEntry.deps.filter(
            (x) => x.type === "subPackage"
          ).map((x) => {
            return `${x.root}/**`;
          }) : [];
          ignore.push(
            ...[
              `${build2.outDir}/**`,
              ...ignoreSubPackage,
              "project.config.json",
              "project.private.config.json",
              "package.json",
              "tsconfig.json",
              "tsconfig.node.json"
            ]
          );
        }
        const files = await (0, import_fast_glob.default)(
          // 假如去 join root 就是返回 absolute
          [import_pathe4.default.join(ctx.srcRoot ?? "", "**/*.{wxml,json,wxs,png,jpg,jpeg,gif,svg,webp}")],
          {
            cwd,
            ignore,
            absolute: false
          }
        );
        const relFiles = files.map((x) => {
          return isSubPackage ? import_pathe4.default.join(weapp?.subPackage?.root ?? "", x) : x;
        });
        for (const file of relFiles) {
          const filepath = import_pathe4.default.resolve(ctx.cwd, file);
          this.addWatchFile(filepath);
          const isMedia = !/\.(?:wxml|json|wxs)$/.test(file);
          this.emitFile({
            type: "asset",
            fileName: ctx.relativeSrcRoot(file),
            source: isMedia ? await import_fs_extra3.default.readFile(filepath) : await import_fs_extra3.default.readFile(filepath, "utf8")
          });
        }
      },
      resolveId(source) {
        if (/\.wxss$/.test(source)) {
          return source.replace(/\.wxss$/, ".css?wxss");
        }
      },
      load(id) {
        if (entriesSet.has(id)) {
          const base = (0, import_shared3.removeExtension)(id);
          const ms = new import_magic_string.default(import_fs_extra3.default.readFileSync(id, "utf8"));
          for (const ext of supportedCssExtensions) {
            const mayBeCssPath = (0, import_shared3.addExtension)(base, ext);
            if (import_fs_extra3.default.existsSync(mayBeCssPath)) {
              this.addWatchFile(mayBeCssPath);
              ms.prepend(`import '${mayBeCssPath}'
`);
            }
          }
          this.addWatchFile(id);
          return {
            code: ms.toString()
          };
        } else if ((0, import_vite.isCSSRequest)(id)) {
          stylesIds.add(id);
          return {
            code: ""
          };
        }
      },
      async buildEnd() {
        const styles = {};
        for (const stylesId of stylesIds) {
          const parsed = parseRequest(stylesId);
          const realPath = getRealPath(parsed);
          if (await import_fs_extra3.default.exists(realPath)) {
            const css = await import_fs_extra3.default.readFile(realPath, "utf8");
            const res = await (0, import_vite.preprocessCSS)(css, stylesId, configResolved);
            const fileName = relative(normalizeCssPath(stylesId));
            if (styles[fileName]) {
              styles[fileName] += res.code;
            } else {
              styles[fileName] = res.code;
            }
          } else {
            stylesIds.delete(stylesId);
          }
        }
        for (const style of Object.entries(styles)) {
          this.emitFile({
            type: "asset",
            fileName: ctx.relativeSrcRoot(style[0]),
            source: style[1]
          });
        }
      }
      // generateBundle(_options, _bundle) {
      //   const files = this.getWatchFiles()
      //   console.log(files)
      // },
    },
    {
      name: "weapp-vite"
    },
    {
      name: "weapp-vite:post",
      enforce: "post"
    }
  ];
}

// src/context.ts
var CompilerContext = class _CompilerContext {
  inlineConfig;
  cwd;
  isDev;
  projectConfig;
  mode;
  packageJson;
  subPackage;
  watcherMap;
  subPackageContextMap;
  type;
  parent;
  constructor(options) {
    const { cwd, isDev, inlineConfig, projectConfig, mode, packageJson, subPackage, type } = (0, import_shared4.defu)(options, {
      cwd: import_node_process2.default.cwd(),
      isDev: false,
      projectConfig: {},
      type: "app",
      inlineConfig: {},
      mode: "",
      packageJson: {}
    });
    this.cwd = cwd;
    this.inlineConfig = inlineConfig;
    this.isDev = isDev;
    this.projectConfig = projectConfig;
    this.mode = mode;
    this.packageJson = packageJson;
    this.subPackage = subPackage;
    this.watcherMap = /* @__PURE__ */ new Map();
    this.subPackageContextMap = /* @__PURE__ */ new Map();
    this.type = type;
  }
  get srcRoot() {
    return this.inlineConfig?.weapp?.srcRoot;
  }
  relativeSrcRoot(p) {
    if (this.srcRoot) {
      return import_pathe5.default.relative(this.srcRoot, p);
    }
    return p;
  }
  get mpDistRoot() {
    return this.projectConfig.miniprogramRoot || this.projectConfig.srcMiniprogramRoot || "";
  }
  // get weappConfig() {
  //   return this.inlineConfig.weapp
  // }
  // get inlineSubPackageConfig() {
  //   return this.weappConfig?.subPackage
  // }
  forkSubPackage(subPackage) {
    const ctx = new _CompilerContext({
      cwd: this.cwd,
      isDev: this.isDev,
      projectConfig: this.projectConfig,
      inlineConfig: this.inlineConfig,
      type: "subPackage",
      mode: this.mode,
      subPackage
    });
    this.subPackageContextMap.set(subPackage.root, ctx);
    ctx.parent = this;
    return ctx;
  }
  async internalDev(inlineConfig) {
    const rollupWatcher = await (0, import_vite2.build)(
      inlineConfig
    );
    const key = "rollup";
    const watcher = this.watcherMap.get(key);
    watcher?.close();
    this.watcherMap.set(key, rollupWatcher);
    return rollupWatcher;
  }
  async runDev() {
    if (import_node_process2.default.env.NODE_ENV === void 0) {
      import_node_process2.default.env.NODE_ENV = "development";
    }
    const inlineConfig = (0, import_shared4.defu)(
      this.inlineConfig,
      {
        root: this.cwd,
        mode: "development",
        plugins: [vitePluginWeapp(this)],
        build: {
          watch: {},
          minify: false,
          emptyOutDir: false
        },
        weapp: {
          type: "app"
        }
      }
    );
    const getWatcher = (paths, opts, inlineConfig2) => {
      const watcher = (0, import_chokidar.watch)(paths, opts);
      let isReady = false;
      watcher.on("all", async (eventName) => {
        if (isReady && (eventName === "add" || eventName === "change" || eventName === "unlink")) {
          await this.internalDev(inlineConfig2);
        }
      }).on("ready", async () => {
        await this.internalDev(inlineConfig2);
        isReady = true;
      });
      return watcher;
    };
    if (this.type === "subPackage" && this.subPackage) {
      const subPackageInlineConfig = Object.assign({}, inlineConfig, {
        weapp: {
          srcRoot: this.parent?.srcRoot,
          type: this.type,
          subPackage: this.subPackage
        }
      });
      const { paths, ...opts } = (0, import_shared4.defu)(
        subPackageInlineConfig.weapp?.watch,
        {
          cwd: import_pathe5.default.join(this.cwd, subPackageInlineConfig.weapp.srcRoot ?? "", this.subPackage.root)
        },
        getWeappWatchOptions()
      );
      const watcher = getWatcher(paths, opts, subPackageInlineConfig);
      this.watcherMap.set(this.subPackage.root, watcher);
      return watcher;
    } else if (this.type === "app") {
      const { paths, ...opts } = (0, import_shared4.defu)(
        inlineConfig.weapp?.watch,
        {
          ignored: [
            import_pathe5.default.join(this.mpDistRoot, "**")
          ],
          cwd: this.cwd
        },
        getWeappWatchOptions()
      );
      const watcher = getWatcher(paths, opts, inlineConfig);
      this.watcherMap.set("/", watcher);
      return watcher;
    }
  }
  async runProd() {
    const inlineConfig = (0, import_shared4.defu)(
      this.inlineConfig,
      {
        root: this.cwd,
        plugins: [vitePluginWeapp(this)],
        mode: "production",
        weapp: {
          type: "app"
        }
      }
    );
    const output = await (0, import_vite2.build)(
      inlineConfig
    );
    return output;
  }
  build() {
    if (this.isDev) {
      return this.runDev();
    } else {
      return this.runProd();
    }
  }
  async loadDefaultConfig() {
    const projectConfig = getProjectConfig(this.cwd);
    this.projectConfig = projectConfig;
    const packageJsonPath = import_pathe5.default.resolve(this.cwd, "package.json");
    const external = [];
    if (await import_fs_extra4.default.exists(packageJsonPath)) {
      const localPackageJson = await import_fs_extra4.default.readJson(packageJsonPath, {
        throws: false
      }) || {};
      this.packageJson = localPackageJson;
      if (localPackageJson.dependencies) {
        external.push(...Object.keys(localPackageJson.dependencies));
      }
    }
    const loaded = await (0, import_vite2.loadConfigFromFile)({
      command: this.isDev ? "serve" : "build",
      mode: this.mode
    }, void 0, this.cwd);
    this.inlineConfig = (0, import_shared4.defu)({
      mode: this.mode,
      build: {
        rollupOptions: {
          output: {
            format: "cjs",
            strict: false,
            entryFileNames: (chunkInfo) => {
              const name = this.relativeSrcRoot(chunkInfo.name);
              if (name.endsWith(".ts")) {
                const baseFileName = (0, import_shared4.removeExtension)(name);
                if (baseFileName.endsWith(".wxs")) {
                  return import_pathe5.default.normalize(baseFileName);
                }
                return import_pathe5.default.normalize((0, import_shared4.addExtension)(baseFileName, ".js"));
              }
              return import_pathe5.default.normalize(name);
            }
          },
          external
        },
        assetsDir: ".",
        commonjsOptions: {
          transformMixedEsModules: true,
          include: void 0
        }
      },
      plugins: [
        (0, import_vite_tsconfig_paths.default)()
      ],
      configFile: false
    }, loaded?.config, this.inlineConfig);
  }
};

// package.json
var version = "1.1.1";

// src/constants.ts
var VERSION = version;

// src/cli.ts
var cli = (0, import_cac.cac)("weapp-vite");
function filterDuplicateOptions(options) {
  for (const [key, value] of Object.entries(options)) {
    if (Array.isArray(value)) {
      options[key] = value[value.length - 1];
    }
  }
}
function convertBase(v) {
  if (v === 0) {
    return "";
  }
  return v;
}
cli.option("-c, --config <file>", `[string] use specified config file`).option("--base <path>", `[string] public base path (default: /)`, {
  type: [convertBase]
}).option("-l, --logLevel <level>", `[string] info | warn | error | silent`).option("--clearScreen", `[boolean] allow/disable clear screen when logging`).option("-d, --debug [feat]", `[string | boolean] show debug logs`).option("-f, --filter <filter>", `[string] filter debug logs`).option("-m, --mode <mode>", `[string] set env mode`);
cli.command("[root]", "start dev server").alias("serve").alias("dev").action(async (root, options) => {
  filterDuplicateOptions(options);
  const ctx = new CompilerContext({
    cwd: root,
    mode: options.mode,
    isDev: true
  });
  await ctx.loadDefaultConfig();
  await ctx.runDev();
});
cli.command("build [root]", "build for production").option("--target <target>", `[string] transpile target (default: 'modules')`).option("--outDir <dir>", `[string] output directory (default: dist)`).option(
  "--sourcemap [output]",
  `[boolean | "inline" | "hidden"] output source maps for build (default: false)`
).option(
  "--minify [minifier]",
  `[boolean | "terser" | "esbuild"] enable/disable minification, or specify minifier to use (default: esbuild)`
).option(
  "--emptyOutDir",
  `[boolean] force empty outDir when it's outside of root`
).option("-w, --watch", `[boolean] rebuilds when modules have changed on disk`).action(async (root, options) => {
  filterDuplicateOptions(options);
  const ctx = new CompilerContext({
    cwd: root,
    mode: options.mode
  });
  await ctx.loadDefaultConfig();
  await ctx.runProd();
});
cli.command("init").action(() => {
  try {
    (0, import_init.initConfig)({
      command: "weapp-vite"
    });
  } catch (error) {
    logger_default.error(error);
  } finally {
    import_node_process3.default.exit();
  }
});
cli.command("open").action(async () => {
  try {
    await (0, import_weapp_ide_cli.parse)(["open", "-p"]);
  } catch (error) {
    logger_default.error(error);
  } finally {
    import_node_process3.default.exit();
  }
});
cli.command("npm").alias("build:npm").alias("build-npm").action(async () => {
  try {
    await (0, import_weapp_ide_cli.parse)(["build-npm", "-p"]);
  } catch (error) {
    logger_default.error(error);
  } finally {
    import_node_process3.default.exit();
  }
});
cli.help();
cli.version(VERSION);
cli.parse();
