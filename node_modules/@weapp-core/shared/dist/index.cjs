"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../node_modules/.pnpm/tsup@8.2.4_jiti@1.21.6_postcss@8.4.41_tsx@4.17.0_typescript@5.5.4_yaml@2.5.0/node_modules/tsup/assets/cjs_shims.js
var init_cjs_shims = __esm({
  "../../node_modules/.pnpm/tsup@8.2.4_jiti@1.21.6_postcss@8.4.41_tsx@4.17.0_typescript@5.5.4_yaml@2.5.0/node_modules/tsup/assets/cjs_shims.js"() {
    "use strict";
  }
});

// ../../node_modules/.pnpm/is-primitive@3.0.1/node_modules/is-primitive/index.js
var require_is_primitive = __commonJS({
  "../../node_modules/.pnpm/is-primitive@3.0.1/node_modules/is-primitive/index.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function isPrimitive(val) {
      if (typeof val === "object") {
        return val === null;
      }
      return typeof val !== "function";
    };
  }
});

// ../../node_modules/.pnpm/isobject@3.0.1/node_modules/isobject/index.js
var require_isobject = __commonJS({
  "../../node_modules/.pnpm/isobject@3.0.1/node_modules/isobject/index.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    module2.exports = function isObject2(val) {
      return val != null && typeof val === "object" && Array.isArray(val) === false;
    };
  }
});

// ../../node_modules/.pnpm/is-plain-object@2.0.4/node_modules/is-plain-object/index.js
var require_is_plain_object = __commonJS({
  "../../node_modules/.pnpm/is-plain-object@2.0.4/node_modules/is-plain-object/index.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var isObject2 = require_isobject();
    function isObjectObject(o) {
      return isObject2(o) === true && Object.prototype.toString.call(o) === "[object Object]";
    }
    module2.exports = function isPlainObject2(o) {
      var ctor, prot;
      if (isObjectObject(o) === false) return false;
      ctor = o.constructor;
      if (typeof ctor !== "function") return false;
      prot = ctor.prototype;
      if (isObjectObject(prot) === false) return false;
      if (prot.hasOwnProperty("isPrototypeOf") === false) {
        return false;
      }
      return true;
    };
  }
});

// ../../node_modules/.pnpm/set-value@4.1.0/node_modules/set-value/index.js
var require_set_value = __commonJS({
  "../../node_modules/.pnpm/set-value@4.1.0/node_modules/set-value/index.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var { deleteProperty } = Reflect;
    var isPrimitive = require_is_primitive();
    var isPlainObject2 = require_is_plain_object();
    var isObject2 = (value) => {
      return typeof value === "object" && value !== null || typeof value === "function";
    };
    var isUnsafeKey = (key) => {
      return key === "__proto__" || key === "constructor" || key === "prototype";
    };
    var validateKey = (key) => {
      if (!isPrimitive(key)) {
        throw new TypeError("Object keys must be strings or symbols");
      }
      if (isUnsafeKey(key)) {
        throw new Error(`Cannot set unsafe key: "${key}"`);
      }
    };
    var toStringKey = (input) => {
      return Array.isArray(input) ? input.flat().map(String).join(",") : input;
    };
    var createMemoKey = (input, options) => {
      if (typeof input !== "string" || !options) return input;
      let key = input + ";";
      if (options.arrays !== void 0) key += `arrays=${options.arrays};`;
      if (options.separator !== void 0) key += `separator=${options.separator};`;
      if (options.split !== void 0) key += `split=${options.split};`;
      if (options.merge !== void 0) key += `merge=${options.merge};`;
      if (options.preservePaths !== void 0) key += `preservePaths=${options.preservePaths};`;
      return key;
    };
    var memoize = (input, options, fn) => {
      const key = toStringKey(options ? createMemoKey(input, options) : input);
      validateKey(key);
      const value = setValue.cache.get(key) || fn();
      setValue.cache.set(key, value);
      return value;
    };
    var splitString = (input, options = {}) => {
      const sep = options.separator || ".";
      const preserve = sep === "/" ? false : options.preservePaths;
      if (typeof input === "string" && preserve !== false && /\//.test(input)) {
        return [input];
      }
      const parts = [];
      let part = "";
      const push = (part2) => {
        let number;
        if (part2.trim() !== "" && Number.isInteger(number = Number(part2))) {
          parts.push(number);
        } else {
          parts.push(part2);
        }
      };
      for (let i = 0; i < input.length; i++) {
        const value = input[i];
        if (value === "\\") {
          part += input[++i];
          continue;
        }
        if (value === sep) {
          push(part);
          part = "";
          continue;
        }
        part += value;
      }
      if (part) {
        push(part);
      }
      return parts;
    };
    var split = (input, options) => {
      if (options && typeof options.split === "function") return options.split(input);
      if (typeof input === "symbol") return [input];
      if (Array.isArray(input)) return input;
      return memoize(input, options, () => splitString(input, options));
    };
    var assignProp = (obj, prop, value, options) => {
      validateKey(prop);
      if (value === void 0) {
        deleteProperty(obj, prop);
      } else if (options && options.merge) {
        const merge = options.merge === "function" ? options.merge : Object.assign;
        if (merge && isPlainObject2(obj[prop]) && isPlainObject2(value)) {
          obj[prop] = merge(obj[prop], value);
        } else {
          obj[prop] = value;
        }
      } else {
        obj[prop] = value;
      }
      return obj;
    };
    var setValue = (target, path, value, options) => {
      if (!path || !isObject2(target)) return target;
      const keys = split(path, options);
      let obj = target;
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const next = keys[i + 1];
        validateKey(key);
        if (next === void 0) {
          assignProp(obj, key, value, options);
          break;
        }
        if (typeof next === "number" && !Array.isArray(obj[key])) {
          obj = obj[key] = [];
          continue;
        }
        if (!isObject2(obj[key])) {
          obj[key] = {};
        }
        obj = obj[key];
      }
      return target;
    };
    setValue.split = split;
    setValue.cache = /* @__PURE__ */ new Map();
    setValue.clear = () => {
      setValue.cache = /* @__PURE__ */ new Map();
    };
    module2.exports = setValue;
  }
});

// ../../node_modules/.pnpm/get-value@3.0.1/node_modules/get-value/index.js
var require_get_value = __commonJS({
  "../../node_modules/.pnpm/get-value@3.0.1/node_modules/get-value/index.js"(exports2, module2) {
    "use strict";
    init_cjs_shims();
    var isObject2 = require_isobject();
    module2.exports = function(target, path, options) {
      if (!isObject2(options)) {
        options = { default: options };
      }
      if (!isValidObject(target)) {
        return typeof options.default !== "undefined" ? options.default : target;
      }
      if (typeof path === "number") {
        path = String(path);
      }
      const isArray = Array.isArray(path);
      const isString = typeof path === "string";
      const splitChar = options.separator || ".";
      const joinChar = options.joinChar || (typeof splitChar === "string" ? splitChar : ".");
      if (!isString && !isArray) {
        return target;
      }
      if (isString && path in target) {
        return isValid(path, target, options) ? target[path] : options.default;
      }
      let segs = isArray ? path : split(path, splitChar, options);
      let len = segs.length;
      let idx = 0;
      do {
        let prop = segs[idx];
        if (typeof prop === "number") {
          prop = String(prop);
        }
        while (prop && prop.slice(-1) === "\\") {
          prop = join([prop.slice(0, -1), segs[++idx] || ""], joinChar, options);
        }
        if (prop in target) {
          if (!isValid(prop, target, options)) {
            return options.default;
          }
          target = target[prop];
        } else {
          let hasProp = false;
          let n = idx + 1;
          while (n < len) {
            prop = join([prop, segs[n++]], joinChar, options);
            if (hasProp = prop in target) {
              if (!isValid(prop, target, options)) {
                return options.default;
              }
              target = target[prop];
              idx = n - 1;
              break;
            }
          }
          if (!hasProp) {
            return options.default;
          }
        }
      } while (++idx < len && isValidObject(target));
      if (idx === len) {
        return target;
      }
      return options.default;
    };
    function join(segs, joinChar, options) {
      if (typeof options.join === "function") {
        return options.join(segs);
      }
      return segs[0] + joinChar + segs[1];
    }
    function split(path, splitChar, options) {
      if (typeof options.split === "function") {
        return options.split(path);
      }
      return path.split(splitChar);
    }
    function isValid(key, target, options) {
      if (typeof options.isValid === "function") {
        return options.isValid(key, target);
      }
      return true;
    }
    function isValidObject(val) {
      return isObject2(val) || Array.isArray(val) || typeof val === "function";
    }
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  addExtension: () => addExtension,
  arrify: () => arrify,
  defu: () => defu,
  defuOverrideArray: () => defuOverrideArray,
  escapeStringRegexp: () => escapeStringRegexp,
  get: () => import_get_value.default,
  isObject: () => isObject,
  removeExtension: () => removeExtension,
  set: () => import_set_value.default
});
module.exports = __toCommonJS(src_exports);
init_cjs_shims();
var import_node_path = require("path");

// ../../node_modules/.pnpm/defu@6.1.4/node_modules/defu/dist/defu.mjs
init_cjs_shims();
function isPlainObject(value) {
  if (value === null || typeof value !== "object") {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  if (prototype !== null && prototype !== Object.prototype && Object.getPrototypeOf(prototype) !== null) {
    return false;
  }
  if (Symbol.iterator in value) {
    return false;
  }
  if (Symbol.toStringTag in value) {
    return Object.prototype.toString.call(value) === "[object Module]";
  }
  return true;
}
function _defu(baseObject, defaults, namespace = ".", merger) {
  if (!isPlainObject(defaults)) {
    return _defu(baseObject, {}, namespace, merger);
  }
  const object = Object.assign({}, defaults);
  for (const key in baseObject) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = baseObject[key];
    if (value === null || value === void 0) {
      continue;
    }
    if (merger && merger(object, key, value, namespace)) {
      continue;
    }
    if (Array.isArray(value) && Array.isArray(object[key])) {
      object[key] = [...value, ...object[key]];
    } else if (isPlainObject(value) && isPlainObject(object[key])) {
      object[key] = _defu(
        value,
        object[key],
        (namespace ? `${namespace}.` : "") + key.toString(),
        merger
      );
    } else {
      object[key] = value;
    }
  }
  return object;
}
function createDefu(merger) {
  return (...arguments_) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    arguments_.reduce((p, c) => _defu(p, c, "", merger), {})
  );
}
var defu = createDefu();
var defuFn = createDefu((object, key, currentValue) => {
  if (object[key] !== void 0 && typeof currentValue === "function") {
    object[key] = currentValue(object[key]);
    return true;
  }
});
var defuArrayFn = createDefu((object, key, currentValue) => {
  if (Array.isArray(object[key]) && typeof currentValue === "function") {
    object[key] = currentValue(object[key]);
    return true;
  }
});

// src/index.ts
var import_set_value = __toESM(require_set_value(), 1);
var import_get_value = __toESM(require_get_value(), 1);
function escapeStringRegexp(str) {
  return str.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function removeExtension(file) {
  return file.replace(/\.[^/.]+$/, "");
}
function addExtension(filename, ext = ".js") {
  let result = `${filename}`;
  if (!(0, import_node_path.extname)(filename)) {
    result += ext;
  }
  return result;
}
function arrify(val) {
  return Array.isArray(val) ? val : [val];
}
var defuOverrideArray = createDefu((obj, key, value) => {
  if (Array.isArray(obj[key]) && Array.isArray(value)) {
    obj[key] = value;
    return true;
  }
});
function isObject(x) {
  return typeof x === "object" && x !== null;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  addExtension,
  arrify,
  defu,
  defuOverrideArray,
  escapeStringRegexp,
  get,
  isObject,
  removeExtension,
  set
});
/*! Bundled license information:

is-primitive/index.js:
  (*!
   * is-primitive <https://github.com/jonschlinkert/is-primitive>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

isobject/index.js:
  (*!
   * isobject <https://github.com/jonschlinkert/isobject>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-plain-object/index.js:
  (*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

set-value/index.js:
  (*!
   * set-value <https://github.com/jonschlinkert/set-value>
   *
   * Copyright (c) Jon Schlinkert (https://github.com/jonschlinkert).
   * Released under the MIT License.
   *)

get-value/index.js:
  (*!
   * get-value <https://github.com/jonschlinkert/get-value>
   *
   * Copyright (c) 2014-2018, Jon Schlinkert.
   * Released under the MIT License.
   *)
*/
